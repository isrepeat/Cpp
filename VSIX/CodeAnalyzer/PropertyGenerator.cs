using System;
using System.Text;
using System.Linq;
using System.Threading;
using System.Collections.Generic;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using CodeAnalyzer.Ex;


namespace System.Runtime.CompilerServices {
    internal static class IsExternalInit { }
}


namespace CodeAnalyzer {
    [Generator]
    public sealed class PropertyGenerator : IIncrementalGenerator {
        private string __logPrefix = "[CodeAnalyzer.PropertyGenerator]";

        public void Initialize(IncrementalGeneratorInitializationContext context) {
            //if (!System.Diagnostics.Debugger.IsAttached) {
            //    System.Diagnostics.Debugger.Launch();
            //}

            var fieldsValueProvider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: this.IsCandidateField,
                    transform: this.TransformToCompoundFieldMetadata)
                .Where(f => f != null)
                .Collect();


            var classList = fieldsValueProvider
                .Select((fields, _) => {
                    var result = new List<Class>();
                    var grouped = new Dictionary<INamedTypeSymbol, List<Field>>(SymbolEqualityComparer.Default);

                    foreach (var field in fields) {
                        var classSymbol = field.Symbol?.ContainingType;
                        if (classSymbol == null) {
                            continue;
                        }

                        if (!grouped.TryGetValue(classSymbol, out var fieldList)) {
                            fieldList = new List<Field>();
                            grouped[classSymbol] = fieldList;
                        }

                        fieldList.Add(field);
                    }

                    foreach (var entry in grouped) {
                        var symbol = entry.Key;
                        var fieldList = entry.Value;

                        result.Add(new Class(symbol, fieldList));
                    }

                    return result.ToImmutableArray();
                });


            context.RegisterSourceOutput(classList, this.GenerateCode);
        }


        private bool IsCandidateField(SyntaxNode node, CancellationToken _) {
            return node is FieldDeclarationSyntax field &&
                   field.AttributeLists.Count > 0;
        }


        private Field TransformToCompoundFieldMetadata(GeneratorSyntaxContext context, CancellationToken _) {
            var fieldSyntax = (FieldDeclarationSyntax)context.Node;
            var variable = fieldSyntax.Declaration.Variables.First();
            var fieldSymbol = context.SemanticModel.GetDeclaredSymbol(variable) as IFieldSymbol;

            if (fieldSymbol == null) {
                return null;
            }

            var field = new Field(fieldSyntax, fieldSymbol);
            if (field.PropertyAttributes.Count > 0) {
                return field;
            }
            return null;
        }


        private void GenerateCode(
            SourceProductionContext context,
            ImmutableArray<Class> classes
            ) {
            //if (!System.Diagnostics.Debugger.IsAttached) {
            //    System.Diagnostics.Debugger.Launch();
            //}

            Reporter.Msg(context, "[PropertyGenerator] GenerateCode() start");
            Reporter.Msg(context, $"[PropertyGenerator] classes.Count = {classes.Length}");

            foreach (var cls in classes) {
                var fields = cls.Fields;

                var className = cls.Name;
                var containingNamespace = cls.Namespace;

                var sb = new StringBuilder();
                sb.AppendLine("// Generated by 'CodeAnalyzer.PropertyGenerator'");
                sb.AppendLine($"namespace {containingNamespace} {{");

                bool hasGeneratedInheritaceCode = this.TryGenerateInheritanceCode(context, cls, "        ", out var inheritanceCode);
                if (hasGeneratedInheritaceCode) {
                    sb.AppendLine($"    public partial class {className} {inheritanceCode} {{");
                }
                else {
                    sb.AppendLine($"    public partial class {className} {{");
                }

                bool hasGeneratedFieldsCode = this.TryGenerateFieldsCode(context, cls, "        ", out var fieldsCode);
                if (hasGeneratedFieldsCode) {
                    if (hasGeneratedInheritaceCode) {
                        sb.AppendLine();
                    }
                    sb.AppendLine($"{fieldsCode}");
                }

                bool hasGeneratedPropertiesCode = this.TryGeneratePropertiesCode(context, cls, "        ", out var propertiesCode);
                if (hasGeneratedPropertiesCode) {
                    if (hasGeneratedFieldsCode) {
                        sb.AppendLine();
                        sb.AppendLine();
                    }
                    sb.AppendLine($"{propertiesCode}");

                }

                bool hasGeneratedMethodsCode = this.TryGenerateMethodsCode(context, cls, "        ", out var methodsCode);
                if (hasGeneratedMethodsCode) {
                    if (hasGeneratedPropertiesCode) {
                        sb.AppendLine();
                        sb.AppendLine();
                    }
                    sb.AppendLine($"{methodsCode}");

                }

                bool hasGeneratedNestedClassesCode = this.TryGenerateNestedClassesCode(context, cls, "        ", out var nestedClassesCode);
                if (hasGeneratedNestedClassesCode) {
                    if (hasGeneratedMethodsCode) {
                        sb.AppendLine();
                        sb.AppendLine();
                    }
                    sb.AppendLine($"{nestedClassesCode}");
                }

                sb.AppendLine("    }");
                sb.AppendLine("}");

                var fileName = $"{className}.g.cs";
                context.AddSource(fileName, SourceText.From(sb.ToString(), Encoding.UTF8));

                Reporter.Msg(context, $"[PropertyGenerator] generated code:");
                Reporter.Msg(context, $"{sb}", ReporterIdentationMarker.LineNumber);
            }

            Reporter.Msg(context, "[PropertyGenerator] GenerateCode() end");
        }



        private bool TryGenerateInheritanceCode(
            SourceProductionContext context,
            Class cls,
            string indent,
            out string result
            ) {
            result = string.Empty;

            var interfaceNames = new List<string>();

            if (cls.ex_HasFieldAttribute<InvalidatablePropertyAttr>() ||
                cls.ex_HasFieldAttribute<InvalidatableLazyPropertyAttr>()
                ) {
                interfaceNames.Add("Helpers.IInvalidatable");
            }

            if (interfaceNames.Count == 0) {
                return false;
            }

            string code = $":\n";
            for (int i = 0; i < interfaceNames.Count; i++) {
                bool isLastInterface = (i == interfaceNames.Count - 1);
                var interfaceName = interfaceNames[i];

                string comma = isLastInterface ? "" : ",";
                string newLine = isLastInterface ? "" : "\n";

                code += $"{indent}{interfaceName}{comma}{newLine}";
            }

            result = code;
            return result.Length > 0;
        }


        private bool TryGenerateFieldsCode(
            SourceProductionContext context,
            Class cls,
            string indent,
            out string result
            ) {
            result = string.Empty;

            string newLine = $"\n{indent}";
            var code = "";

            var invalidatableFields = cls.Fields
                .Where(field => field.ex_HasAttribute<InvalidatablePropertyAttr>() ||
                                field.ex_HasAttribute<InvalidatableLazyPropertyAttr>())
                .ToList();

            if (invalidatableFields.Count > 0) {
                code += $"{newLine}private readonly InvalidatablePropertiesState _invalidatablePropertiesState = new();";
            }

            //if (invalidatableFields.Count > 0) {
            //    code += $"{newLine}private readonly Lazy<InvalidatablePropertiesState> _invalidatablePropertiesStateLazy = new(() => new InvalidatablePropertiesState(";

            //    for (int i = 0; i < invalidatableFields.Count; i++) {
            //        bool isLastField = (i == invalidatableFields.Count - 1);
            //        var f = invalidatableFields[i];

            //        code += $"{newLine}    {f.Name}";

            //        if (!isLastField) {
            //            code += $",";
            //        }
            //    }

            //    code += $"{newLine}));";
            //}

            result = code.StartsWith("\n")
                ? code.Substring(1)
                : code;

            return result.Length > 0;
        }



        private bool TryGeneratePropertiesCode(
            SourceProductionContext context,
            Class cls,
            string indent,
            out string result
            ) {
            result = string.Empty;

            string newLine = $"\n{indent}";
            string code = "";

            for (int i = 0; i < cls.Fields.Count; i++) {
                bool isLastField = (i == cls.Fields.Count - 1);
                var field = cls.Fields[i];

                if (this.TryGeneratePropertyCode(context, field, indent, out var propertyCode)) {
                    code += $"{propertyCode}";
                    if (!isLastField) {
                        code += $"\n\n\n";
                    }
                }
            }

            result = code.StartsWith("\n")
                ? code.Substring(1)
                : code;

            return result.Length > 0;
        }


        private bool TryGeneratePropertyCode(
            SourceProductionContext context,
            Field field,
            string indent,
            out string result
            ) {
            result = string.Empty;

            var attrs = field.PropertyAttributes;

            // Определяем необходимость геттера и сеттера
            bool hasGetter = attrs.Any(a => a.GetterAccess == GetterAccess.Get);
            bool hasSetter = attrs.Any(a => a.SetterAccess is SetterAccess.Set or SetterAccess.PrivateSet);

            // Если есть несколько атрибутов, где один требует Set, а другой PrivateSet — выбираем наиболее ограниченный
            SetterAccess setterAccess = SetterAccess.None;

            if (attrs.Any(a => a.SetterAccess == SetterAccess.PrivateSet)) {
                setterAccess = SetterAccess.PrivateSet;
            }
            else if (attrs.Any(a => a.SetterAccess == SetterAccess.Set)) {
                setterAccess = SetterAccess.Set;
            }

            var hasObservableAttribute = field.ex_HasAttribute<ObservablePropertyAttr>();
            var hasInvalidatableAttribute = field.ex_HasAttribute<InvalidatablePropertyAttr>();
            var hasInvalidatableLazyAttribute = field.ex_HasAttribute<InvalidatableLazyPropertyAttr>();
            var hasAnyInvalidatableAttribute = hasInvalidatableAttribute | hasInvalidatableLazyAttribute;

            var invalidatableLazyAttribute = field.PropertyAttributes.OfType<InvalidatableLazyPropertyAttr>().FirstOrDefault();

            // Validation:
            if (hasObservableAttribute && !hasSetter) {
                Reporter.Error(context, $"{__logPrefix} 'ObservablePropertyAttr' need setter, but another attribute suppress setter");
                return false;
            }
            if (hasInvalidatableAttribute && hasInvalidatableLazyAttribute) {
                Reporter.Error(context, $"{__logPrefix} Do not support both attributes 'InvalidatablePropertyAttr' and 'InvalidatableLazyPropertyAttr'");
                return false;
            }

            string newLine = $"\n{indent}";
            string code = "";

            code += $"{newLine}public {field.TypeName} {field.PropName} {{";

            if (hasGetter) {
                code += $"{newLine}    get {{";

                if (hasAnyInvalidatableAttribute) {
                    code += $"{newLine}        if (!_invalidatablePropertiesState.Is{field.PropName}Valid) {{";
                    code += $"{newLine}            return default;";
                    code += $"{newLine}        }}";
                }

                if (hasInvalidatableLazyAttribute) {
                    code += $"{newLine}        if ({field.Name} == null) {{";
                    code += $"{newLine}            {field.Name} = this.{invalidatableLazyAttribute.FactoryMethodName}();";
                    code += $"{newLine}        }}";
                }

                code += $"{newLine}        return {field.Name};";
                code += $"{newLine}    }}";
            }

            if (hasSetter) {
                string setterAccessStr = setterAccess == SetterAccess.PrivateSet ? "private " : "";
                code += $"{newLine}    {setterAccessStr}set {{";

                if (hasAnyInvalidatableAttribute) {
                    code += $"{newLine}        if (!_invalidatablePropertiesState.Is{field.PropName}Valid) {{";
                    code += $"{newLine}            return;";
                    code += $"{newLine}        }}";
                }

                code += $"{newLine}        if ({field.Name} != value) {{";
                code += $"{newLine}            {field.Name} = value;";

                if (hasAnyInvalidatableAttribute) {
                    code += $"{newLine}            _invalidatablePropertiesState.{field.PropName}Cached = value;";
                }

                if (hasObservableAttribute) {
                    code += $"{newLine}            base.OnPropertyChanged(nameof(this.{field.PropName}));";
                }

                code += $"{newLine}        }}";
                code += $"{newLine}    }}";
            }

            code += $"{newLine}}}";

            if (hasAnyInvalidatableAttribute) {
                code += $"{newLine}";
                code += $"{newLine}public {field.TypeName} {field.PropName}Cached {{";
                code += $"{newLine}    get {{";
                code += $"{newLine}        if (_invalidatablePropertiesState.{field.PropName}Cached == null) {{";
                code += $"{newLine}            _invalidatablePropertiesState.{field.PropName}Cached = {field.Name};";
                code += $"{newLine}        }}";
                code += $"{newLine}        return ({field.TypeName})_invalidatablePropertiesState.{field.PropName}Cached;";
                code += $"{newLine}    }}";
                code += $"{newLine}}}";
            }

            result = code.StartsWith("\n")
                ? code.Substring(1)
                : code;

            return result.Length > 0;
        }



        private bool TryGenerateMethodsCode(
            SourceProductionContext context,
            Class cls,
            string indent,
            out string result
            ) {
            result = string.Empty;

            string newLine = $"\n{indent}";
            string code = "";

            var invalidatableFields = cls.Fields
                .Where(field => field.ex_HasAttribute<InvalidatablePropertyAttr>() ||
                                field.ex_HasAttribute<InvalidatableLazyPropertyAttr>())
                .ToList();

            if (invalidatableFields.Count > 0) {
                code += $"{newLine}private void InvalidateProperties() {{";
                code += $"{newLine}    _invalidatablePropertiesState.InvalidateAll();";
                code += $"{newLine}}}";
            }

            result = code.StartsWith("\n")
                ? code.Substring(1)
                : code;

            return result.Length > 0;
        }



        private bool TryGenerateNestedClassesCode(
            SourceProductionContext context,
            Class cls,
            string indent,
            out string result
            ) {
            result = string.Empty;

            string newLine = $"\n{indent}";
            string code = "";
            
            //
            // Generate InvalidatablePropertiesState class
            //
            var invalidatableFields = cls.Fields
                .Where(field => field.ex_HasAttribute<InvalidatablePropertyAttr>() ||
                                field.ex_HasAttribute<InvalidatableLazyPropertyAttr>())
                .ToList();

            if (invalidatableFields.Count > 0) {
                code += $"{newLine}private sealed class InvalidatablePropertiesState {{";

                foreach (var f in invalidatableFields) {
                    code += $"{newLine}    public {f.TypeName}? {f.PropName}Cached {{ get; set; }}";
                    code += $"{newLine}    public bool Is{f.PropName}Valid {{ get; private set; }}";
                }

                //code += $"{newLine}";
                //code += $"{newLine}    public InvalidatablePropertiesState(";

                //for (int i = 0; i < invalidatableFields.Count; i++) {
                //    var f = invalidatableFields[i];
                //    bool isLastField = (i == invalidatableFields.Count - 1);
                    
                //    string comma = isLastField ? "" : ",";
                    
                //    code += $"{newLine}        {f.TypeName} {f.Name}{comma}";
                //}

                //code += $"{newLine}    ) {{";

                //foreach (var f in invalidatableFields) {
                //    code += $"{newLine}        this.{f.PropName}Cached = {f.Name};";
                //    code += $"{newLine}        this.Is{f.PropName}Valid = true;";
                //}

                //code += $"{newLine}    }}";

                code += $"{newLine}";
                code += $"{newLine}    public void InvalidateAll() {{";

                foreach (var f in invalidatableFields) {
                    code += $"{newLine}        this.Is{f.PropName}Valid = false;";
                }

                code += $"{newLine}    }}";
                code += $"{newLine}}}";
            }

            result = code.StartsWith("\n")
                ? code.Substring(1)
                : code;

            return result.Length > 0;
        }
    }
}